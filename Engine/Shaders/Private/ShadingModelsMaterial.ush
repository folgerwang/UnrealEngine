// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	ShadingModelsMaterial.usf: Pixel shader function for computing a GBuffer from shading model.
=============================================================================*/

#include "SubsurfaceProfileCommon.ush"

// Optimization: if opacity is 0 then revert to default shading model 
#define SUBSURFACE_PROFILE_OPACITY_THRESHOLD 1

void SetGBufferForShadingModel(
	in out FGBufferData GBuffer, 
	in const FMaterialPixelParameters MaterialParameters,
	const float Opacity,
	const half3 BaseColor,
	const half  Metallic,
	const half  Specular,
	const float Roughness,
	const float3 SubsurfaceColor,
	const float SubsurfaceProfile,
	const float dither)
{
	GBuffer.WorldNormal = MaterialParameters.WorldNormal;
	GBuffer.BaseColor = BaseColor;
	GBuffer.Metallic = Metallic;
	GBuffer.Specular = Specular;
	GBuffer.Roughness = Roughness;

#if MATERIAL_SHADINGMODEL_UNLIT
	GBuffer.ShadingModelID = SHADINGMODELID_UNLIT;
#elif MATERIAL_SHADINGMODEL_DEFAULT_LIT
	GBuffer.ShadingModelID = SHADINGMODELID_DEFAULT_LIT;
#elif MATERIAL_SHADINGMODEL_SUBSURFACE
	GBuffer.ShadingModelID = SHADINGMODELID_SUBSURFACE;
	GBuffer.CustomData.rgb = EncodeSubsurfaceColor(SubsurfaceColor);
	GBuffer.CustomData.a = Opacity;
#elif MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN
	GBuffer.ShadingModelID = SHADINGMODELID_PREINTEGRATED_SKIN;
	GBuffer.CustomData.rgb = EncodeSubsurfaceColor(SubsurfaceColor);
	GBuffer.CustomData.a = Opacity;
#elif MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE
	// Optimization: if opacity is 0 then revert to default shading model 
	#if SUBSURFACE_PROFILE_OPACITY_THRESHOLD
	if (Opacity > 0.0)
	#endif
	{
		GBuffer.ShadingModelID = SHADINGMODELID_SUBSURFACE_PROFILE;
		GBuffer.CustomData.rgb = EncodeSubsurfaceProfile(SubsurfaceProfile);
		GBuffer.CustomData.a = Opacity;

		// Average roughness for dual specular.
		uint SubsurfaceProfileUInt = uint(SubsurfaceProfile * 255.0f + 0.5f);
		float MaterialRoughnessToAverage = ActualSSProfilesTexture.Load(int3(SSSS_DUAL_SPECULAR_OFFSET, SubsurfaceProfileUInt, 0)).w * SSSS_MAX_DUAL_SPECULAR_ROUGHNESS;

		// Smooth blend out dual specular when opacity is low.
		MaterialRoughnessToAverage = lerp(1.0f, MaterialRoughnessToAverage, saturate(Opacity * 10.0f));

		GBuffer.Roughness = saturate(GBuffer.Roughness * MaterialRoughnessToAverage);
	}
	#if SUBSURFACE_PROFILE_OPACITY_THRESHOLD
	else
	{
		GBuffer.ShadingModelID = SHADINGMODELID_DEFAULT_LIT;
		GBuffer.CustomData = 0;
	}
	#endif
#elif MATERIAL_SHADINGMODEL_CLEAR_COAT
	GBuffer.ShadingModelID = SHADINGMODELID_CLEAR_COAT;

	float ClearCoat				= saturate( GetMaterialCustomData0(MaterialParameters) );
	float ClearCoatRoughness	= saturate( GetMaterialCustomData1(MaterialParameters) );
	float MetalSpec = 0.9;

	float NoV = saturate( dot( MaterialParameters.WorldNormal, MaterialParameters.CameraVector ) );

	// Approximation of refraction's effect on EnvBRDF
	float RefractionScale = ( (NoV * 0.5 + 0.5) * NoV - 1 ) * saturate( 1.25 - 1.25 * Roughness ) + 1;

	// Approximation of absorption integral, tuned for Roughness=0.4
	float3 AbsorptionColor = BaseColor * (1 / MetalSpec);
	float3 Absorption = AbsorptionColor * ( (NoV - 1) * 0.85 * ( 1 - lerp( AbsorptionColor, Square(AbsorptionColor), -0.78 ) ) + 1 );

	float F0 = 0.04;
	float Fc = Pow5( 1 - NoV );
	float F = Fc + (1 - Fc) * F0;
	float LayerAttenuation = lerp( 1, (1 - F), ClearCoat );

	GBuffer.BaseColor = lerp( BaseColor * LayerAttenuation, MetalSpec * Absorption * RefractionScale, Metallic * ClearCoat );
	GBuffer.BaseColor+= dither / 255.f;
	GBuffer.Specular *= lerp( 1, RefractionScale, ClearCoat );

	GBuffer.CustomData.x = ClearCoat;
	GBuffer.CustomData.y = ClearCoatRoughness;

	#if CLEAR_COAT_BOTTOM_NORMAL
	{
		float2 oct2 = UnitVectorToOctahedron(GBuffer.WorldNormal);

		#if NUM_MATERIAL_OUTPUTS_CLEARCOATBOTTOMNORMAL > 0
			#if MATERIAL_TANGENTSPACENORMAL
				float3 tempnormal = normalize(TransformTangentVectorToWorld( MaterialParameters.TangentToWorld, ClearCoatBottomNormal0(MaterialParameters) ));
			#else
				float3 tempnormal =  ClearCoatBottomNormal0(MaterialParameters);
			#endif

			float2 oct1 = UnitVectorToOctahedron(tempnormal);
			float2 oct3 = ( (oct1 - oct2) *  0.5 ) + (128.0/255.0);
			GBuffer.CustomData.a = oct3.x;
			GBuffer.CustomData.z = oct3.y;
		#else
			GBuffer.CustomData.a = 128.0/255.0;
			GBuffer.CustomData.z = 128.0/255.0;
		#endif
	}
	#endif
#elif MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
	GBuffer.ShadingModelID = SHADINGMODELID_TWOSIDED_FOLIAGE;
	GBuffer.CustomData.rgb = EncodeSubsurfaceColor(SubsurfaceColor);
	GBuffer.CustomData.a = Opacity;
#elif MATERIAL_SHADINGMODEL_HAIR
	GBuffer.ShadingModelID = SHADINGMODELID_HAIR;
	GBuffer.CustomData.xy = UnitVectorToOctahedron( MaterialParameters.WorldNormal ) * 0.5 + 0.5;
	GBuffer.CustomData.z = saturate( GetMaterialCustomData0(MaterialParameters) );	// Backlit
#elif MATERIAL_SHADINGMODEL_CLOTH
	GBuffer.ShadingModelID = SHADINGMODELID_CLOTH;
	GBuffer.CustomData.rgb = SubsurfaceColor;
	GBuffer.CustomData.a = saturate( GetMaterialCustomData0(MaterialParameters) );	// Cloth
	GBuffer.IndirectIrradiance *= 1 - GBuffer.CustomData.a;
#elif MATERIAL_SHADINGMODEL_EYE
	GBuffer.ShadingModelID = SHADINGMODELID_EYE;
	GBuffer.CustomData.x = EncodeSubsurfaceProfile(SubsurfaceProfile).x;
	GBuffer.CustomData.w = 1.0f - saturate(GetMaterialCustomData0(MaterialParameters));	// Opacity = 1.0 - Iris Mask
	GBuffer.Metallic = saturate(GetMaterialCustomData1(MaterialParameters));			// Iris Distance

#if IRIS_NORMAL
	float IrisMask		= saturate( GetMaterialCustomData0(MaterialParameters) );
	float IrisDistance	= saturate( GetMaterialCustomData1(MaterialParameters) );

	GBuffer.CustomData.x = EncodeSubsurfaceProfile(SubsurfaceProfile).x;
	GBuffer.CustomData.w = 1.0 - IrisMask;	// Opacity

	float2 WorldNormalOct = UnitVectorToOctahedron( GBuffer.WorldNormal );

	// CausticNormal stored as octahedron
	#if NUM_MATERIAL_OUTPUTS_GETTANGENTOUTPUT > 0
		// Blend in the negative intersection normal to create some concavity
		// Not great as it ties the concavity to the convexity of the cornea surface
		// No good justification for that. On the other hand, if we're just looking to
		// introduce some concavity, this does the job.
		float3 PlaneNormal = normalize( GetTangentOutput0(MaterialParameters) );
		float3 CausticNormal = normalize( lerp( PlaneNormal, -GBuffer.WorldNormal, IrisMask*IrisDistance ) );
		float2 CausticNormalOct  = UnitVectorToOctahedron( CausticNormal );
		float2 CausticNormalDelta = ( CausticNormalOct - WorldNormalOct ) * 0.5 + (128.0/255.0);
		GBuffer.Metallic = CausticNormalDelta.x;
		GBuffer.Specular = CausticNormalDelta.y;
	#else
		float3 PlaneNormal = GBuffer.WorldNormal;
		GBuffer.Metallic = 128.0/255.0;
		GBuffer.Specular = 128.0/255.0;
	#endif

	// IrisNormal CustomData.yz
	#if NUM_MATERIAL_OUTPUTS_CLEARCOATBOTTOMNORMAL > 0
		float3 IrisNormal = normalize( ClearCoatBottomNormal0(MaterialParameters) );
		#if MATERIAL_TANGENTSPACENORMAL
			IrisNormal = normalize( TransformTangentVectorToWorld( MaterialParameters.TangentToWorld, IrisNormal ) );
		#endif
	#else
		float3 IrisNormal = PlaneNormal;
	#endif

	float2 IrisNormalOct  = UnitVectorToOctahedron( IrisNormal );
	float2 IrisNormalDelta = ( IrisNormalOct - WorldNormalOct ) * 0.5 + (128.0/255.0);
	GBuffer.CustomData.yz = IrisNormalDelta;
#else
	GBuffer.Metallic = saturate(GetMaterialCustomData1(MaterialParameters));			// Iris Distance

	#if NUM_MATERIAL_OUTPUTS_GETTANGENTOUTPUT > 0
		float3 Tangent = GetTangentOutput0(MaterialParameters);
		GBuffer.CustomData.yz = UnitVectorToOctahedron( normalize(Tangent) ) * 0.5 + 0.5;
	#endif
#endif
#else
	// missing shading model, compiler should report ShadingModelID is not set
#endif
}
