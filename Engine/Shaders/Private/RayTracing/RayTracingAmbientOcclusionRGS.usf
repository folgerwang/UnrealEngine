// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../Montecarlo.ush"
#include "../DeferredShadingCommon.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "RayTracingCommon.ush"

RaytracingAccelerationStructure TLAS;
RWTexture2D<float4> RWOcclusionMaskUAV;
RWTexture2D<float> RWRayDistanceUAV;

uint CalcLinearIndex(uint2 PixelCoord)
{
	return PixelCoord.y * View.BufferSizeAndInvSize.x + PixelCoord.x;
}

// #patrick todo: move to RayTracingCommon.ush
float3 ReconstructWorldPositionFromDepth(float2 UV, float Depth)
{
	float2 ScreenPosition = (UV - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
	float4 HomogeneousWorldPosition = mul(float4(ScreenPosition * Depth, Depth, 1), View.ScreenToWorld);
	float3 WorldPosition = HomogeneousWorldPosition.xyz / HomogeneousWorldPosition.w;

	return WorldPosition;
}

void GenerateCosineNormalRay(
	float3 WorldPosition,
	float3 WorldNormal,
	inout RandomSequence RandSequence,
	out float3 RayOrigin,
	out float3 RayDirection,
	out float RayTMin,
	out float RayTMax
)
{
	// Draw random variable
	float2 BufferSize = View.BufferSizeAndInvSize.xy;
	uint DummyVariable;
	float2 RandSample = RandomSequence_GenerateSample2D(RandSequence, DummyVariable);

	// Perform cosine-hemispherical sampling and convert to world-space
	float4 Direction_Tangent = CosineSampleHemisphere(RandSample);
	float3 Direction_World = TangentToWorld(Direction_Tangent.xyz, WorldNormal);

	RayOrigin = WorldPosition + WorldNormal * 0.01;
	RayDirection = Direction_World;
	RayTMin = 0.0;
	RayTMax = AmbientOcclusion.MaxRayDistance;
}

[shader("raygeneration")]
void AmbientOcclusionRGS()
{
	uint2 PixelCoord = DispatchRaysIndex().xy;

	RandomSequence RandSequence;
	uint LinearIndex = CalcLinearIndex(PixelCoord);
	RandomSequence_Initialize(RandSequence, LinearIndex, View.FrameNumber);

	// Get G-Buffer surface data
	float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
	float2 UV = (float2(PixelCoord) + 0.5) * InvBufferSize;
	FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(UV);
	float Depth = ScreenSpaceData.GBuffer.Depth;
	float3 WorldPosition = ReconstructWorldPositionFromDepth(UV, Depth);
	float3 WorldNormal = ScreenSpaceData.GBuffer.WorldNormal;

	float Visibility = 0.0;
	float RayDistance = 0.0;
	float HitCount = 0.0;
	uint SamplesPerPixel = AmbientOcclusion.SamplesPerPixel;
	
	// Mask out depth values beyond far plane
	if (Depth >= SCENE_TEXTURES_DISABLED_SCENE_DEPTH_VALUE)
	{
		SamplesPerPixel = 0.0;
		Visibility = 1.0;
	}

	for (uint SampleIndex = 0; SampleIndex < SamplesPerPixel; ++SampleIndex)
	{
		RayDesc Ray;
		GenerateCosineNormalRay(WorldPosition, WorldNormal, RandSequence, Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
		if (dot(WorldNormal, Ray.Direction) > 0.0)
		{
			uint RayFlags = 0
				| RAY_FLAG_CULL_BACK_FACING_TRIANGLES;

			FDefaultPayload Payload = (FDefaultPayload)0;

			TraceRay(
				TLAS,
				RayFlags,
				0xFF, // InstanceInclusionMask
				0,    // RayContributionToHitGroupIndex
				1,    // MultiplierForGeometryContributionToShaderIndex
				0,    // MissShaderIndex
				Ray,
				Payload
			);

			Visibility += Payload.HitT < 0 ? 1.0 : 0.0;
			if (Payload.HitT >= 0.0)
			{
				RayDistance += Payload.HitT;
				HitCount += 1.0;
			}
		}
		else
		{
			Visibility += 0.0;
			RayDistance += 0.0;
			HitCount += 1.0;
		}
	}

	RWOcclusionMaskUAV[PixelCoord] = Visibility;
	if (SamplesPerPixel > 0)
	{
		RWOcclusionMaskUAV[PixelCoord] /= SamplesPerPixel;
	}

	if (HitCount > 0.0)
	{
		RWRayDistanceUAV[PixelCoord] = RayDistance / HitCount;
	}
	else
	{
		RWRayDistanceUAV[PixelCoord] = 1.0e27;
	}
}