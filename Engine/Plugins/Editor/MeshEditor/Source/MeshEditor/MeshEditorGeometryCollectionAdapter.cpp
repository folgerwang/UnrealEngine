// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "MeshEditorGeometryCollectionAdapter.h"
#include "EditableMesh.h"
#include "MeshAttributes.h"
#include "WireframeMeshComponent.h"
#include "EditorSupportDelegates.h"
#include "GeometryCollection/GeometryCollection.h"
#include "GeometryCollection/GeometryCollectionAlgo.h"
#include "GeometryCollection/GeometryCollectionObject.h"

namespace GeometryCollectionAdapter
{
	static FColor GetEdgeColor(bool bIsHardEdge, bool bIsUVSeam)
	{
		return FColor::White;
	}
} // GeometryCollectionAdapter

UMeshEditorGeometryCollectionAdapter::UMeshEditorGeometryCollectionAdapter() : WireFrameEnabled(false)
{

}

void UMeshEditorGeometryCollectionAdapter::Initialize( UEditableMesh* EditableMesh, UWireframeMesh* InWireframeMesh )
{
	WireframeMesh = InWireframeMesh;
}

void UMeshEditorGeometryCollectionAdapter::OnRebuildRenderMeshStart( const UEditableMesh* EditableMesh, const bool bInvalidateLighting )
{
	if (WireFrameEnabled == false)
		return;

	for( TObjectIterator<UWireframeMeshComponent> It( RF_ClassDefaultObject, false, EInternalObjectFlags::PendingKill ); It; ++It )
	{
		if( It->GetWireframeMesh() == WireframeMesh )
		{
			if( It->IsRenderStateCreated() )
			{
				check( It->IsRegistered() );
				It->UnregisterComponent();
			}
		}
	}

	WireframeMesh->ReleaseResources();

	// Flush the rendering commands generated by the detachments.
	FlushRenderingCommands();
}


void UMeshEditorGeometryCollectionAdapter::OnRebuildRenderMesh(const UEditableMesh* EditableMesh)
{
	check(EditableMesh);
	WireframeMesh->Reset();
	if (WireFrameEnabled == false)
		return;

	const FMeshDescription* MeshDescription = EditableMesh->GetMeshDescription();
	check(MeshDescription);

	const FEditableMeshSubMeshAddress& SubMeshAddress = EditableMesh->GetSubMeshAddress();

	// Add all vertices
	TVertexAttributesConstRef<FVector> VertexPositions = MeshDescription->VertexAttributes().GetAttributesRef<FVector>(MeshAttribute::Vertex::Position);

	if (UGeometryCollection* GeometryCollectionObject = Cast<UGeometryCollection>(static_cast<UObject*>(EditableMesh->GetSubMeshAddress().MeshObjectPtr)))
	{
		TSharedPtr<FGeometryCollection> GeometryCollectionPtr = GeometryCollectionObject->GetGeometryCollection();
		if (FGeometryCollection* GeometryCollection = GeometryCollectionPtr.Get())
		{
			TSharedRef<TManagedArray<int32> >  BoneMapArray = GeometryCollection->GetAttribute<int32>("BoneMap", FGeometryCollection::VerticesGroup);
			TManagedArray<int32>& BoneMap = *BoneMapArray;

			TArray<FTransform> BoneTransforms;
			GeometryCollectionAlgo::GlobalMatrices(GeometryCollection, BoneTransforms);
			checkSlow(GeometryCollection->Transform->Num() == BoneTransforms.Num());

			for (const FVertexID VertexID : MeshDescription->Vertices().GetElementIDs())
			{
				FVector VertexPosition = VertexPositions[VertexID];
				int32 Bone = BoneMap[VertexID.GetValue()];
				FTransform BoneTtransform = BoneTransforms[Bone];
				VertexPosition = BoneTtransform.TransformPosition(VertexPosition);

				WireframeMesh->AddVertex(VertexID);
				WireframeMesh->SetVertexPosition(VertexID, VertexPosition);
			}

			// Add all edges
			TEdgeAttributesConstRef<bool> EdgeHardnesses = MeshDescription->EdgeAttributes().GetAttributesRef<bool>(MeshAttribute::Edge::IsHard);
			TEdgeAttributesConstRef<bool> EdgeUVSeams = MeshDescription->EdgeAttributes().GetAttributesRef<bool>(MeshAttribute::Edge::IsUVSeam);
			for (const FEdgeID EdgeID : MeshDescription->Edges().GetElementIDs())
			{
				WireframeMesh->AddEdge(EdgeID);
				WireframeMesh->SetEdgeVertices(EdgeID, EditableMesh->GetEdgeVertex(EdgeID, 0), EditableMesh->GetEdgeVertex(EdgeID, 1));
				WireframeMesh->SetEdgeColor(EdgeID, GeometryCollectionAdapter::GetEdgeColor(EdgeHardnesses[EdgeID], EdgeUVSeams[EdgeID]));
			}

			TManagedArray<FGeometryCollectionBoneNode>& Hierarchy = *GeometryCollection->BoneHierarchy;
			for (int Element = 0; Element < Hierarchy.Num(); Element++)
			{
				if (Hierarchy[Element].IsGeometry())
				{
					AddPolygonGroupToWireframe(MeshDescription, Element, EditableMesh);
				}
			}
		}
	}
}


void UMeshEditorGeometryCollectionAdapter::AddPolygonGroupToWireframe(const FMeshDescription* MeshDescription, int SelectedPolygonGroup, const UEditableMesh* EditableMesh)
{
	if (WireFrameEnabled == false)
		return;

	if (SelectedPolygonGroup == -1)
		return;

	if (UGeometryCollection* GeometryCollectionObject = Cast<UGeometryCollection>(static_cast<UObject*>(EditableMesh->GetSubMeshAddress().MeshObjectPtr)))
	{
		TSharedPtr<FGeometryCollection> GeometryCollectionPtr = GeometryCollectionObject->GetGeometryCollection();
		if (FGeometryCollection* GeometryCollection = GeometryCollectionPtr.Get())
		{
			check(GeometryCollection);
			TSharedRef<TManagedArray<FGeometryCollectionBoneNode> > HierarchyArray = GeometryCollection->GetAttribute<FGeometryCollectionBoneNode>("BoneHierarchy", FGeometryCollection::TransformGroup);
			TManagedArray<FGeometryCollectionBoneNode>& Hierarchy = *HierarchyArray;

			FColor PolygonGroupColour = FColor::Blue;

			const TArray<FPolygonID>& PolygonGroupIDs = MeshDescription->GetPolygonGroupPolygons(FPolygonGroupID(SelectedPolygonGroup));
			if (PolygonGroupIDs.Num() > 0)
			{
				// Add all polygons and edge instances
				TPolygonAttributesConstRef<FVector> PolygonNormals = MeshDescription->PolygonAttributes().GetAttributesRef<FVector>(MeshAttribute::Polygon::Normal);

				for (const FPolygonID PolygonID : PolygonGroupIDs)
				{
					WireframeMesh->AddPolygon(PolygonID);
					WireframeMesh->SetPolygonNormal(PolygonID, PolygonNormals[PolygonID]);

					const int32 NumEdges = EditableMesh->GetPolygonPerimeterEdgeCount(PolygonID);
					for (int32 Index = 0; Index < NumEdges; ++Index)
					{
						bool bOutWindingIsReversed;
						FEdgeID EdgeID = EditableMesh->GetPolygonPerimeterEdge(PolygonID, Index, bOutWindingIsReversed);
						WireframeMesh->SetEdgeColor(EdgeID, PolygonGroupColour);
						WireframeMesh->AddEdgeInstance(EdgeID, PolygonID);
					}
				}
			}
		}
	}
}

void UMeshEditorGeometryCollectionAdapter::OnRebuildRenderMeshFinish( const UEditableMesh* EditableMesh, const bool bRebuildBoundsAndCollision, const bool bIsPreviewRollback )
{
	if (WireFrameEnabled == false)
		return;

	const FMeshDescription* MeshDescription = EditableMesh->GetMeshDescription();
	check( MeshDescription );

	TPolygonAttributesConstRef<FVector> PolygonNormals = MeshDescription->PolygonAttributes().GetAttributesRef<FVector>( MeshAttribute::Polygon::Normal );
	for( const FPolygonID PolygonID : EditableMesh->PolygonsPendingNewTangentBasis )
	{
		WireframeMesh->SetPolygonNormal( PolygonID, PolygonNormals[ PolygonID ] );
	}

	WireframeMesh->InitResources();

	for( TObjectIterator<UWireframeMeshComponent> It( RF_ClassDefaultObject, false, EInternalObjectFlags::PendingKill ); It; ++It )
	{
		if( It->GetWireframeMesh() == WireframeMesh )
		{
			if( !It->IsRenderStateCreated() )
			{
				It->RegisterComponent();
			}
		}
	}
}


void UMeshEditorGeometryCollectionAdapter::OnStartModification( const UEditableMesh* EditableMesh, const EMeshModificationType MeshModificationType, const EMeshTopologyChange MeshTopologyChange )
{
}


void UMeshEditorGeometryCollectionAdapter::OnEndModification( const UEditableMesh* EditableMesh )
{
}


void UMeshEditorGeometryCollectionAdapter::OnReindexElements( const UEditableMesh* EditableMesh, const FElementIDRemappings& Remappings )
{
}


bool UMeshEditorGeometryCollectionAdapter::IsCommitted( const UEditableMesh* EditableMesh ) const
{
	return false;
}


bool UMeshEditorGeometryCollectionAdapter::IsCommittedAsInstance( const UEditableMesh* EditableMesh ) const
{
	return false;
}


void UMeshEditorGeometryCollectionAdapter::OnCommit( UEditableMesh* EditableMesh )
{
}


UEditableMesh* UMeshEditorGeometryCollectionAdapter::OnCommitInstance( UEditableMesh* EditableMesh, UPrimitiveComponent* ComponentToInstanceTo )
{
	return nullptr;
}


void UMeshEditorGeometryCollectionAdapter::OnRevert( UEditableMesh* EditableMesh )
{
}


UEditableMesh* UMeshEditorGeometryCollectionAdapter::OnRevertInstance( UEditableMesh* EditableMesh )
{
	return nullptr;
}


void UMeshEditorGeometryCollectionAdapter::OnPropagateInstanceChanges( UEditableMesh* EditableMesh )
{
}


void UMeshEditorGeometryCollectionAdapter::OnDeleteVertexInstances( const UEditableMesh* EditableMesh, const TArray<FVertexInstanceID>& VertexInstanceIDs )
{
}


void UMeshEditorGeometryCollectionAdapter::OnDeleteOrphanVertices( const UEditableMesh* EditableMesh, const TArray<FVertexID>& VertexIDs )
{
	if (WireFrameEnabled == false)
		return;

	for( const FVertexID VertexID : VertexIDs )
	{
		WireframeMesh->RemoveVertex( VertexID );
	}
}


void UMeshEditorGeometryCollectionAdapter::OnCreateEmptyVertexRange( const UEditableMesh* EditableMesh, const TArray<FVertexID>& VertexIDs )
{
	if (WireFrameEnabled == false)
		return;

	for( const FVertexID VertexID : VertexIDs )
	{
		WireframeMesh->AddVertex( VertexID );
	}
}


void UMeshEditorGeometryCollectionAdapter::OnCreateVertices( const UEditableMesh* EditableMesh, const TArray<FVertexID>& VertexIDs )
{
	if (WireFrameEnabled == false)
		return;

	const FMeshDescription* MeshDescription = EditableMesh->GetMeshDescription();
	check( MeshDescription );

	TVertexAttributesConstRef<FVector> VertexPositions = MeshDescription->VertexAttributes().GetAttributesRef<FVector>( MeshAttribute::Vertex::Position );
	for( const FVertexID VertexID : VertexIDs )
	{
		WireframeMesh->AddVertex( VertexID );
		WireframeMesh->SetVertexPosition( VertexID, VertexPositions[ VertexID ] );
	}
}


void UMeshEditorGeometryCollectionAdapter::OnCreateVertexInstances( const UEditableMesh* EditableMesh, const TArray<FVertexInstanceID>& VertexInstanceIDs )
{
}


void UMeshEditorGeometryCollectionAdapter::OnSetVertexAttribute( const UEditableMesh* EditableMesh, const FVertexID VertexID, const FMeshElementAttributeData& Attribute )
{
	if (WireFrameEnabled == false)
		return;

	if( Attribute.AttributeName == MeshAttribute::Vertex::Position )
	{
		WireframeMesh->SetVertexPosition( VertexID, Attribute.AttributeValue.GetValue<FVector>() );
	}
}


void UMeshEditorGeometryCollectionAdapter::OnCreateEdges( const UEditableMesh* EditableMesh, const TArray<FEdgeID>& EdgeIDs )
{
	if (WireFrameEnabled == false)
		return;

	const FMeshDescription* MeshDescription = EditableMesh->GetMeshDescription();
	check( MeshDescription );

	TEdgeAttributesConstRef<bool> EdgeHardnesses = MeshDescription->EdgeAttributes().GetAttributesRef<bool>( MeshAttribute::Edge::IsHard );
	TEdgeAttributesConstRef<bool> EdgeUVSeams = MeshDescription->EdgeAttributes().GetAttributesRef<bool>( MeshAttribute::Edge::IsUVSeam );

	for( const FEdgeID EdgeID : EdgeIDs )
	{
		WireframeMesh->AddEdge( EdgeID );
		WireframeMesh->SetEdgeVertices( EdgeID, EditableMesh->GetEdgeVertex( EdgeID, 0 ), EditableMesh->GetEdgeVertex( EdgeID, 1 ) );
		WireframeMesh->SetEdgeColor( EdgeID, GeometryCollectionAdapter::GetEdgeColor( EdgeHardnesses[ EdgeID ], EdgeUVSeams[ EdgeID ] ) );

		for( const FPolygonID PolygonID : MeshDescription->GetEdgeConnectedPolygons( EdgeID ) )
		{
			WireframeMesh->AddEdgeInstance( EdgeID, PolygonID );
		}
	}
}


void UMeshEditorGeometryCollectionAdapter::OnDeleteEdges( const UEditableMesh* EditableMesh, const TArray<FEdgeID>& EdgeIDs )
{
	if (WireFrameEnabled == false)
		return;

	const FMeshDescription* MeshDescription = EditableMesh->GetMeshDescription();
	check( MeshDescription );

	for( const FEdgeID EdgeID : EdgeIDs )
	{
		for( const FPolygonID PolygonID : MeshDescription->GetEdgeConnectedPolygons( EdgeID ) )
		{
			WireframeMesh->RemoveEdgeInstance( EdgeID, PolygonID );
		}

		WireframeMesh->RemoveEdge( EdgeID );
	}
}


void UMeshEditorGeometryCollectionAdapter::OnSetEdgesVertices( const UEditableMesh* EditableMesh, const TArray<FEdgeID>& EdgeIDs )
{
	if (WireFrameEnabled == false)
		return;

	for( const FEdgeID EdgeID : EdgeIDs )
	{
		WireframeMesh->SetEdgeVertices( EdgeID, EditableMesh->GetEdgeVertex( EdgeID, 0 ), EditableMesh->GetEdgeVertex( EdgeID, 1 ) );
	}
}


void UMeshEditorGeometryCollectionAdapter::OnSetEdgeAttribute( const UEditableMesh* EditableMesh, const FEdgeID EdgeID, const FMeshElementAttributeData& Attribute )
{
	if (WireFrameEnabled == false)
		return;

	const FMeshDescription* MeshDescription = EditableMesh->GetMeshDescription();
	check( MeshDescription );

	TEdgeAttributesConstRef<bool> EdgeHardnesses = MeshDescription->EdgeAttributes().GetAttributesRef<bool>( MeshAttribute::Edge::IsHard );
	TEdgeAttributesConstRef<bool> EdgeUVSeams = MeshDescription->EdgeAttributes().GetAttributesRef<bool>( MeshAttribute::Edge::IsUVSeam );

	if( Attribute.AttributeName == MeshAttribute::Edge::IsHard ||
		Attribute.AttributeName == MeshAttribute::Edge::IsUVSeam )
	{
		WireframeMesh->SetEdgeColor( EdgeID, GeometryCollectionAdapter::GetEdgeColor( EdgeHardnesses[ EdgeID ], EdgeUVSeams[ EdgeID ] ) );
	}
}


void UMeshEditorGeometryCollectionAdapter::OnCreatePolygons( const UEditableMesh* EditableMesh, const TArray<FPolygonID>& PolygonIDs )
{
	if (WireFrameEnabled == false)
		return;

	const FMeshDescription* MeshDescription = EditableMesh->GetMeshDescription();
	check( MeshDescription );

	TPolygonAttributesConstRef<FVector> PolygonNormals = MeshDescription->PolygonAttributes().GetAttributesRef<FVector>( MeshAttribute::Polygon::Normal );
	for( const FPolygonID PolygonID : PolygonIDs )
	{
		WireframeMesh->AddPolygon( PolygonID );
		WireframeMesh->SetPolygonNormal( PolygonID, PolygonNormals[ PolygonID ] );

		const int32 NumEdges = EditableMesh->GetPolygonPerimeterEdgeCount( PolygonID );
		for( int32 Index = 0; Index < NumEdges; ++Index )
		{
			bool bOutWindingIsReversed;
			WireframeMesh->AddEdgeInstance( EditableMesh->GetPolygonPerimeterEdge( PolygonID, Index, bOutWindingIsReversed ), PolygonID );
		}
	}
}


void UMeshEditorGeometryCollectionAdapter::OnDeletePolygons( const UEditableMesh* EditableMesh, const TArray<FPolygonID>& PolygonIDs )
{
	if (WireFrameEnabled == false)
		return;

	for( const FPolygonID PolygonID : PolygonIDs )
	{
		const int32 NumEdges = EditableMesh->GetPolygonPerimeterEdgeCount( PolygonID );
		for( int32 Index = 0; Index < NumEdges; ++Index )
		{
			bool bOutWindingIsReversed;
			WireframeMesh->RemoveEdgeInstance( EditableMesh->GetPolygonPerimeterEdge( PolygonID, Index, bOutWindingIsReversed ), PolygonID );
		}

		WireframeMesh->RemovePolygon( PolygonID );
	}
}


void UMeshEditorGeometryCollectionAdapter::OnChangePolygonVertexInstances( const UEditableMesh* EditableMesh, const TArray<FPolygonID>& PolygonIDs )
{
}


void UMeshEditorGeometryCollectionAdapter::OnCreatePolygonGroups( const UEditableMesh* EditableMesh, const TArray<FPolygonGroupID>& PolygonGroupIDs )
{
}


void UMeshEditorGeometryCollectionAdapter::OnDeletePolygonGroups( const UEditableMesh* EditableMesh, const TArray<FPolygonGroupID>& PolygonGroupIDs )
{
}


void UMeshEditorGeometryCollectionAdapter::OnRetriangulatePolygons( const UEditableMesh* EditableMesh, const TArray<FPolygonID>& PolygonIDs )
{
}
